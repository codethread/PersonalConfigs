#!/bin/bash

# GitLab Pipeline Watcher
# Monitors running GitLab pipelines for a user and sends notifications when they complete

set -euo pipefail

# Configuration
POLL_INTERVAL=30
USERNAME="adam.hall"
TRACKED_PIPELINES_FILE="/tmp/gitlab-pipeline-watcher-tracked.txt"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log with timestamp and color
log() {
    local level=$1
    local message=$2
    local color=""
    
    case $level in
        "INFO")  color=$BLUE ;;
        "WARN")  color=$YELLOW ;;
        "ERROR") color=$RED ;;
        "SUCCESS") color=$GREEN ;;
    esac
    
    echo -e "${color}[$(date '+%H:%M:%S')] [$level] $message${NC}"
}

# Function to send notification
send_notification() {
    local title=$1
    local body=$2
    local icon=${3:-"info"}
    
    kitten notify --icon="$icon" "$title" "$body"
}

# Function to get status icon for notifications
get_status_icon() {
    local status=$1
    case $status in
        "success") echo "info" ;;
        "failed") echo "error" ;;
        "canceled") echo "warning" ;;
        *) echo "system-monitor" ;;
    esac
}

# Function to get status emoji for terminal
get_status_emoji() {
    local status=$1
    case $status in
        "success") echo "âœ…" ;;
        "failed") echo "âŒ" ;;
        "canceled") echo "âš ï¸" ;;
        "running") echo "ðŸ”„" ;;
        *) echo "â„¹ï¸" ;;
    esac
}

# Function to format pipeline info
format_pipeline_info() {
    local pipeline=$1
    local id=$(echo "$pipeline" | jq -r '.id')
    local status=$(echo "$pipeline" | jq -r '.status')
    local ref=$(echo "$pipeline" | jq -r '.ref' | sed 's|refs/merge-requests/||' | sed 's|/head||')
    local web_url=$(echo "$pipeline" | jq -r '.web_url')
    local updated_at=$(echo "$pipeline" | jq -r '.updated_at')
    
    echo "Pipeline $id (MR $ref) - $status - $updated_at"
}

# Function to get currently running pipelines
get_running_pipelines() {
    glab pipeline list --username="$USERNAME" --status=running --output=json 2>/dev/null || echo "[]"
}

# Function to get pipeline by ID
get_pipeline_by_id() {
    local pipeline_id=$1
    glab pipeline list --username="$USERNAME" --output=json 2>/dev/null | jq -r ".[] | select(.id == $pipeline_id)" || echo ""
}

# Initialize tracked pipelines file
initialize_tracking() {
    if [[ ! -f "$TRACKED_PIPELINES_FILE" ]]; then
        touch "$TRACKED_PIPELINES_FILE"
        log "INFO" "Initialized tracking file: $TRACKED_PIPELINES_FILE"
    fi
}

# Cleanup function
cleanup() {
    log "INFO" "Cleaning up and exiting..."
    rm -f "$TRACKED_PIPELINES_FILE"
    exit 0
}

# Set up signal handlers
trap cleanup SIGINT SIGTERM

# Main monitoring loop
monitor_pipelines() {
    log "INFO" "Starting GitLab pipeline watcher for user: $USERNAME"
    log "INFO" "Polling interval: ${POLL_INTERVAL}s"
    log "INFO" "Press Ctrl+C to stop"
    echo
    
    initialize_tracking
    
    # Get initial running pipelines
    running_pipelines=$(get_running_pipelines)
    if [[ "$running_pipelines" != "[]" ]]; then
        echo "$running_pipelines" | jq -r '.[].id' > "$TRACKED_PIPELINES_FILE"
        log "INFO" "Found $(echo "$running_pipelines" | jq length) running pipeline(s)"
        echo "$running_pipelines" | jq -r '.[] | "\(.id) \(.status) \(.ref | gsub("refs/merge-requests/"; "MR ") | gsub("/head"; ""))"' | while read -r id status ref; do
            log "INFO" "$(get_status_emoji "$status") Tracking Pipeline $id ($ref)"
        done
        echo
    else
        log "INFO" "No running pipelines found"
        echo
    fi
    
    while true; do
        sleep "$POLL_INTERVAL"
        
        # Get current running pipelines
        current_running=$(get_running_pipelines)
        current_running_ids=$(echo "$current_running" | jq -r '.[].id' 2>/dev/null || echo "")
        
        # Read previously tracked pipelines
        if [[ -f "$TRACKED_PIPELINES_FILE" ]]; then
            tracked_ids=$(cat "$TRACKED_PIPELINES_FILE" 2>/dev/null || echo "")
        else
            tracked_ids=""
        fi
        
        # Check for newly started pipelines
        if [[ -n "$current_running_ids" ]]; then
            echo "$current_running_ids" | while read -r pipeline_id; do
                if [[ -n "$pipeline_id" ]] && ! echo "$tracked_ids" | grep -q "^$pipeline_id$"; then
                    pipeline_info=$(echo "$current_running" | jq -r ".[] | select(.id == $pipeline_id)")
                    ref=$(echo "$pipeline_info" | jq -r '.ref' | sed 's|refs/merge-requests/||' | sed 's|/head||')
                    log "INFO" "$(get_status_emoji "running") New pipeline started: $pipeline_id (MR $ref)"
                fi
            done
        fi
        
        # Check for completed pipelines
        if [[ -n "$tracked_ids" ]]; then
            echo "$tracked_ids" | while read -r pipeline_id; do
                if [[ -n "$pipeline_id" ]] && ! echo "$current_running_ids" | grep -q "^$pipeline_id$"; then
                    # Pipeline is no longer running, check its final status
                    completed_pipeline=$(get_pipeline_by_id "$pipeline_id")
                    if [[ -n "$completed_pipeline" ]]; then
                        status=$(echo "$completed_pipeline" | jq -r '.status')
                        ref=$(echo "$completed_pipeline" | jq -r '.ref' | sed 's|refs/merge-requests/||' | sed 's|/head||')
                        web_url=$(echo "$completed_pipeline" | jq -r '.web_url')
                        
                        # Send notification
                        icon=$(get_status_icon "$status")
                        title="GitLab Pipeline $status"
                        body="Pipeline $pipeline_id (MR $ref) has $status"
                        
                        send_notification "$title" "$body" "$icon"
                        
                        # Log completion
                        case $status in
                            "success")
                                log "SUCCESS" "$(get_status_emoji "$status") Pipeline $pipeline_id (MR $ref) completed successfully"
                                ;;
                            "failed")
                                log "ERROR" "$(get_status_emoji "$status") Pipeline $pipeline_id (MR $ref) failed"
                                ;;
                            *)
                                log "WARN" "$(get_status_emoji "$status") Pipeline $pipeline_id (MR $ref) $status"
                                ;;
                        esac
                        
                        log "INFO" "View at: $web_url"
                        echo
                    fi
                fi
            done
        fi
        
        # Update tracked pipelines file
        if [[ -n "$current_running_ids" ]]; then
            echo "$current_running_ids" > "$TRACKED_PIPELINES_FILE"
        else
            > "$TRACKED_PIPELINES_FILE"
        fi
    done
}

# Show help
show_help() {
    cat << EOF
GitLab Pipeline Watcher

USAGE:
    gitlab-pipeline-watcher [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -i, --interval SECONDS  Set polling interval (default: 30)
    -u, --username USER     Set GitLab username (default: adam.hall)

EXAMPLES:
    gitlab-pipeline-watcher                    # Start monitoring with default settings
    gitlab-pipeline-watcher -i 60             # Check every 60 seconds
    gitlab-pipeline-watcher -u john.doe       # Monitor different user

DESCRIPTION:
    Monitors GitLab pipelines for the specified user and sends desktop notifications
    when pipelines complete. Uses 'kitten notify' for notifications and 'glab' CLI
    for GitLab API access.

    The script tracks running pipelines and notifies when they finish with their
    final status (success, failed, canceled, etc.).

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -i|--interval)
            POLL_INTERVAL="$2"
            shift 2
            ;;
        -u|--username)
            USERNAME="$2"
            shift 2
            ;;
        *)
            log "ERROR" "Unknown option: $1"
            echo "Use --help for usage information."
            exit 1
            ;;
    esac
done

# Validate dependencies
if ! command -v glab &> /dev/null; then
    log "ERROR" "glab CLI not found. Please install GitLab CLI."
    exit 1
fi

if ! command -v kitten &> /dev/null; then
    log "ERROR" "kitten not found. Please install Kitty terminal."
    exit 1
fi

if ! command -v jq &> /dev/null; then
    log "ERROR" "jq not found. Please install jq for JSON processing."
    exit 1
fi

# Start monitoring
monitor_pipelines