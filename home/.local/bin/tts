#!/usr/bin/env bash

set -euo pipefail

# Python venv location - this is the only Python thing we care about
VENV="${DOTFILES}/.py_venv"

# Parse arguments
TEXT=""
STRIP_MD=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --text|-t)
            TEXT="$2"
            shift 2
            ;;
        --strip-markdown|-s)
            STRIP_MD=true
            shift
            ;;
        --help|-h)
            echo "Usage: speak [options] or pipe text to stdin"
            echo ""
            echo "Options:"
            echo "  --text, -t TEXT       Provide text as argument"
            echo "  --strip-markdown, -s  Strip markdown formatting before speaking"
            echo "  --help, -h           Show this help"
            echo ""
            echo "Examples:"
            echo "  echo 'Hello' | speak"
            echo "  speak --text 'Hello world'"
            echo "  cat README.md | strip-markdown | speak"
            echo "  cat README.md | speak --strip-markdown"
            exit 0
            ;;
        *)
            echo "Unknown option: $1. Use --help for usage." >&2
            exit 1
            ;;
    esac
done

# Get text from argument or stdin
if [[ -z "$TEXT" ]]; then
    if [[ -t 0 ]]; then
        echo "Error: No input. Pipe text or use --text" >&2
        exit 1
    fi
    TEXT=$(cat)
fi

if [[ -z "$TEXT" ]]; then
    exit 0  # Nothing to speak
fi

# Optionally strip markdown if requested
if [[ "$STRIP_MD" == "true" ]]; then
    # Check if strip-markdown is available
    if command -v strip-markdown &> /dev/null; then
        TEXT=$(echo "$TEXT" | strip-markdown)
    else
        echo "Warning: strip-markdown not found in PATH. Speaking with markdown." >&2
    fi
fi

# Create temp file for audio
TMPFILE=$(mktemp)

# Generate and play audio (suppress ALL output)
{
SPEAK_TEXT="$TEXT" "$VENV/bin/python" -c "
import sys
import os

# Silence everything
os.environ['HF_HUB_DISABLE_PROGRESS_BARS'] = '1'
os.environ['HF_HUB_DISABLE_TELEMETRY'] = '1'
os.environ['TRANSFORMERS_VERBOSITY'] = 'error'
os.environ['TORCH_LOGS'] = '-all'

# Redirect all output
import io
sys.stdout = io.StringIO()
sys.stderr = io.StringIO()

import warnings
warnings.filterwarnings('ignore')

try:
    # Import with output suppressed
    from mlx_audio.tts.generate import generate_audio
    import logging
    logging.disable(logging.CRITICAL)

    # Get text from environment variable to avoid escaping issues
    text = os.environ.get('SPEAK_TEXT', '')

    # Generate audio
    output = generate_audio(
        text=text,
        model_path='prince-canuma/Kokoro-82M',
        voice='af_heart',
        speed=1.0,
        file_prefix='$TMPFILE'.replace('.wav', ''),
        audio_format='wav'
    )
except:
    pass
"
} &>/dev/null

# Find the generated file (mlx-audio adds suffix)
GENERATED=$(ls ${TMPFILE%.wav}_*.wav 2>/dev/null | head -1)
if [[ -z "$GENERATED" ]] && [[ -f "$TMPFILE" ]]; then
    GENERATED="$TMPFILE"
fi

if [[ -n "$GENERATED" ]] && [[ -f "$GENERATED" ]]; then
    # Output the path to stdout for pipeline use
    echo "$GENERATED"
elif [[ -f "$TMPFILE" ]]; then
    # Fallback if no generated file with suffix
    echo "$TMPFILE"
fi