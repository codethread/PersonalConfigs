#!/bin/bash
# :module: Converts YouTube video to system notification sound

# youtube-to-notification-sound
# Downloads a YouTube video and converts it to AIFF format for macOS notifications

set -euo pipefail

# Configuration
SOUNDS_DIR="$HOME/Library/Sounds"
TEMP_DIR="/tmp/youtube-sound-$$"
DEFAULT_DURATION=3
MAX_DURATION=10

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] <youtube_url> <sound_name>

Downloads a YouTube video and converts it to AIFF format for macOS notifications.

ARGUMENTS:
    youtube_url    YouTube URL to download
    sound_name     Name for the sound file (without extension)

OPTIONS:
    -d, --duration SECONDS    Duration to extract (default: $DEFAULT_DURATION, max: $MAX_DURATION)
    -s, --start SECONDS      Start time for extraction (default: 0)
    -v, --volume FACTOR      Volume adjustment factor (default: 1.0, range: 0.1-3.0)
    -h, --help              Show this help message

EXAMPLES:
    $(basename "$0") "https://youtube.com/watch?v=..." "my-alert-sound"
    $(basename "$0") -d 2 -s 10 -v 1.5 "https://youtube.com/watch?v=..." "success-chime"

REQUIREMENTS:
    - yt-dlp: brew install yt-dlp
    - ffmpeg: brew install ffmpeg
EOF
}

log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

check_dependencies() {
    local missing=()
    
    if ! command -v yt-dlp &> /dev/null; then
        missing+=("yt-dlp")
    fi
    
    if ! command -v ffmpeg &> /dev/null; then
        missing+=("ffmpeg")
    fi
    
    if [ ${#missing[@]} -ne 0 ]; then
        error "Missing required dependencies: ${missing[*]}"
        echo "Install with: brew install ${missing[*]}"
        exit 1
    fi
}

cleanup() {
    if [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
        log "Cleaned up temporary files"
    fi
}

validate_args() {
    # Check duration
    if (( $(echo "$duration > $MAX_DURATION" | bc -l) )); then
        error "Duration cannot exceed $MAX_DURATION seconds"
        exit 1
    fi
    
    # Check volume
    if (( $(echo "$volume < 0.1" | bc -l) )) || (( $(echo "$volume > 3.0" | bc -l) )); then
        error "Volume must be between 0.1 and 3.0"
        exit 1
    fi
    
    # Validate YouTube URL
    if [[ ! "$youtube_url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        error "Invalid YouTube URL format"
        exit 1
    fi
    
    # Validate sound name
    if [[ ! "$sound_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "Sound name can only contain letters, numbers, hyphens, and underscores"
        exit 1
    fi
}

# Parse command line arguments
duration=$DEFAULT_DURATION
start_time=0
volume=1.0

while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--duration)
            duration="$2"
            shift 2
            ;;
        -s|--start)
            start_time="$2"
            shift 2
            ;;
        -v|--volume)
            volume="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Check required arguments
if [ $# -ne 2 ]; then
    error "Missing required arguments"
    usage
    exit 1
fi

youtube_url="$1"
sound_name="$2"

# Validate arguments
validate_args

# Check dependencies
log "Checking dependencies..."
check_dependencies
log "Dependencies verified: yt-dlp and ffmpeg are available"

# Set up cleanup trap
trap cleanup EXIT

# Create temporary directory
mkdir -p "$TEMP_DIR"
log "Created temporary directory: $TEMP_DIR"

# Log configuration
log "Configuration: duration=${duration}s, start=${start_time}s, volume=${volume}x"
log "Output file will be: $SOUNDS_DIR/$sound_name.aiff"

# Create sounds directory if it doesn't exist
mkdir -p "$SOUNDS_DIR"

# Check if sound already exists
output_file="$SOUNDS_DIR/$sound_name.aiff"
if [ -f "$output_file" ]; then
    warn "Sound file '$sound_name.aiff' already exists"
    read -p "Overwrite? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "Operation cancelled"
        exit 0
    fi
fi

log "Downloading audio from: $youtube_url"

# Download audio using yt-dlp
yt_dlp_output="$TEMP_DIR/audio.%(ext)s"
log "Running yt-dlp with output template: $yt_dlp_output"
if ! yt-dlp \
    --extract-audio \
    --audio-format wav \
    --audio-quality 0 \
    --output "$yt_dlp_output" \
    "$youtube_url"; then
    error "Failed to download audio from YouTube"
    exit 1
fi
log "yt-dlp download completed successfully"

# Find the downloaded file
log "Searching for downloaded audio file in $TEMP_DIR"
downloaded_file=$(find "$TEMP_DIR" -name "audio.*" -type f | head -1)
if [ ! -f "$downloaded_file" ]; then
    error "Downloaded audio file not found"
    log "Contents of temp directory:"
    ls -la "$TEMP_DIR" || true
    exit 1
fi

log "Downloaded: $(basename "$downloaded_file")"
log "File size: $(du -h "$downloaded_file" | cut -f1)"

# Convert and process audio with ffmpeg
log "Converting to AIFF format (duration: ${duration}s, start: ${start_time}s, volume: ${volume}x)"

ffmpeg_filters="volume=$volume"
log "ffmpeg filters: $ffmpeg_filters"

if ! ffmpeg \
    -i "$downloaded_file" \
    -ss "$start_time" \
    -t "$duration" \
    -af "$ffmpeg_filters" \
    -acodec pcm_s16be \
    -ar 44100 \
    -ac 2 \
    "$output_file" \
    -y \
    -loglevel error; then
    error "Failed to convert audio with ffmpeg"
    exit 1
fi
log "ffmpeg conversion completed successfully"

success "Created notification sound: $output_file"

# Test the sound
log "Testing the sound..."
if command -v kitten &> /dev/null; then
    kitten notify --sound-name "$sound_name" "Sound Test" "Testing your new notification sound: $sound_name"
    success "Test notification sent using kitten notify"
else
    # Fallback to afplay for testing
    afplay "$output_file"
    success "Played sound using afplay"
fi

# Show usage instructions
echo
success "Sound '$sound_name' is ready to use!"
echo "To use in your Claude notifier, update the NOTIFICATION_SOUNDS object:"
echo "  $sound_name: \"$sound_name\","
echo
echo "Test with: kitten notify --sound-name \"$sound_name\" \"Test\" \"Message\""